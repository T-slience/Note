

# 1.数据库的基础操作指令

在所有的指令后面都必须使用;表示结束    

#### 1.数据库相关指令

- ```sql
  # 显示当前时间
  select now();
  # 查看所有数据库
  show databases;
  ```

- ```sql
  #使用数据库
  use 数据库名;
  # 查看当前使用的数据库
  select database();
  ```

- ```sql
  #创建数据库
  create database 数据库名 charset=utf-8;
  #删除数据库
  drop database 数据库名;
  #展示创建库的sql语句
  show create database 数据库名;
  ```

#### 2.表相关指令

- ```sql
  # 查看当前数据库中所有表
  show tables;
  # 创建表
  create table 表名(
      字段名1  数据类型  数据约束
      字段名2  数据类型  数据约束
      ...);
  # 展示创建表的sql语句
  show create table 表名;
  # 删除表
  drop table 表名;
  ```

- ```sql
  #修改表--添加字段
  alter table 表名 add 列名 类型 约束;
  #修改表--删除字段
  alter table 表名 drop 列名;
  #修改表--修改字段(类型)
  alter table  表名 modify 列名 新类型 新约束;
  #修改表--修改字段(名和类型)
  alter table  表名 change 新表名 新类型 新约束;
  ```

#### 3.表数据相关操作

- 基础操作--增删改查

  - ```sql
    # 查询所有列 (*通配所有字符)
    select * from 表名;
    # 查询指定列
    select 字段1,字段2...from 表名;
    ```

  - ```sql
    # 添加数据

    #(values 代表可以同时插入多行,value只能插入一行)
    #全列插入(要和表的列一一对应)
    insert into 表名 values(....),(....)...;
    #部分列插入(可以对部分列插入,但是其他数据必须有默认值或者没有设置not null)
    insert into 表名(列名1,列名2...) values(列1的值,列2的值...);
    ```

  - ```sql
    # 修改数据(如果没有条件,则会修改整个表)
    update 表名 set 列1 = 值1 ,列2=值2... where 条件;
    # 删除数据
    delete from 表名 where 条件;
    ```

  - ```sql
    #使用delete删除称之为物理删除,一旦删除就不容易恢复,我们可以使用逻辑删除的方式来解决这个问题
    # 添加 代表删除的字段, 0表示未删除 1表示删除
    alter table 表名 add is_delete bit default 0;
    # 逻辑删除数据
    update 表名 set is_delete = 1 where 条件
    
    # 逻辑删除的本质是添加字段并修改值,代表其删除,值依旧存在,但是我们在看到is_delete = 1 时可以认为其已经删除了,后面可以通过筛选的方式查看达到看不到的效果 
    ```


# 2.数据库的进阶操作指令
#### 1.进阶操作

- ```sql
  # as 关键字
  # 用于给表或者字段起别名
  select id as 序号, name as 名字,gender as 性别 from students;
  select s.id, s.name ,s.gender from students as s;
  
  # 给字段起别名,其在显示数据时会以别名作为列名
  # 给表其别名,之后调用其数据则只能用别名,而不能用原名,这点在连接查询时很有用
  ```

- ```sql
  # distinct 关键字
  # 去除重复数据行(对一行多个数据,必须完全相同才会去除显示)
  select distinct name ,gender from  students;
  ```

- ```sql
  # 排序
  select * from 表名 order by 列1 asc/desc , 列2 asc/desc...;
  # 若第一列值相同,则按第二列值排序.....
  # asc  ascend  升序 
  # desc decend  降序
  # 列名不输入时,默认为升序
  ```

- ```sql
  #分页查询
  # 数据过多,一页显示不完,需要多页显示
  select * from 表名 limit start ,count;
  # limit 表示查询关键字
  # start 表示开始索引,不输入时默认为0
  # count 表示查询条数
  # 已知每页显示m条数据，求第n页显示的数据(实际使用时,需要输入具体值)
  select * from students limit (n-1)*m,m
  ```
- ```sql
  # 聚合函数
  # count(col): 表示求指定列的总行数
  # 返回非Null数据的总行数
  select count(height) from students; 
  # 返回总行数,包含null
  select count(*) from students;
  
  # max(col): 表示求指定列的最大值
  select max(age) from students where gender = 2;
  
  # min(col): 表示求指定列的最小值
  select min(height) from students where gender =2;
  
  # avg(col): 表示求指定列的和
  # sum(col): 表示求指定列的平均值
  
  # ifnull : 表示当判定字段为null时,使用设定值参与计算
  select avg(ifnull(height,180))from students where gender =2;
  
  #聚合函数 是对一个组的某列数据进行统计或者计算并返回一个值,在默认情况下,整个表为一个组,但是在使用group by 之后,会根据组的情况,返回相应数量的值;
  
  ```



#### 2.查询操作

- ```sql
  # where 条件查询
  # 比较运算符:  等于 = , 大于 > ,大于等于 >= 
  #  小于等于 <= , 小于 < , 不等于 != or <> ;
  
  # 逻辑运算符: and ,or ,not
  
  # 范围查询 : 连续范围: between .. and...
             #非连续范围 : in (数据集合)
  
  # 空判断(只能用is 不能用=)(null代表没有指向,不等同于空字符串)
      #判断为空 : is null;
      #判断非空: is not null ;
  
  #模糊查询: like 模糊查询关键字  %代表多个任意字符  _代表一个任意字符
   select * from students where name like "黄%";
  ```

- ```sql
  # 分组查询
  # 根据指定字段进行分组
  # group by 列名 [having 条件] [with rollup]
  # 在 group by 中,条件只能使用 having 而不能使用 where
  # with rollup 用来统计 每列的结果
  select name, gender from students group by name, gender;
  select gender,count(*) from students group by gender having count(*)>2;
  select gender,group_concat(age) from students group by gender with rollup
  
  # 当时用 group by 时,表结构已经发生了变化,从二维表格变成了三维表格
  # 此时需要用到 group_concat(字段名) 将该字段的多行数据进行拼接显示, 不然会报错
  select gender,group_concat(name) from students group by gender;
  ```

- ```sql
  # 连接查询
  # 实现多个表的查询
  # 只能用 on 不能用 where
  # 不使用on时,显示的是笛卡尔积,即左表和右表的每条数据分别组合
  selcet * from 左表 (as a) join 右表 (as b)  on 条件;
  
  # 自连接 (取得两个表中有关联的数据)
  select * from 左表 (inner) join 右表 on 条件;
  
  # 左连接 (在自连接的基础上,加上左表的全部数据 ,右边以Null填充)
  select * from 左表 left join 右表 on 条件;
  
  # 右连接 (在自连接的基础上,加上右表的全部数据 ,左边以Null填充)
  select * from 左表 rigth join 右表 on 条件;
  
  # 自连接 (自己查自己,必须起别名)
  select * from 表名 as a (inner) join 表名 as b on 条件;
  ```

- ```sql
  # 子查询
  # 在一个 select 语句中(主查询),嵌套了另一个select语句(子查询)
  
  # 标量子查询 (子查询返回的结果为一个值)
  select avg(age) from students;
  
  # 列子查询 (子查询返回的结果是 一列多行)
  select name from kongfu where id in (select kongfuid from hero);
  
  # 行子查询 (子查询的返回的结果是 一行多列)
  select * from students where (age,height) =
  (select max(age), max(height) from students);
  ```

#### 3.SQL的执行顺序和书写顺序

```sql
(8)SELECT (9)DISTINCT<select_list>
(1)FROM <left_table>
(2)<join_type>JOIN<right_table>
(3) ON <join_condition>
(4)WHERE <where_condition>
(5)GROUP BY <group_by_list>
(6)WITH {CUBE|ROLLUP}
(7)HAVING<having_condition>
(10)ORDER BY<order_by_list>
(11)LIMIT <limit_number>
```



# 3.数据库设计

#### 1.数据库设计 -- 三范式

- 范式: 对设计数据库提出的一些规范,目前有迹可循的共有八种, 一般遵守三范式即可	

  

#### 2.第一范式 (1NF)

- 强调 列的原子性,即列不能够再分成其他几列
- ![1nf](C:\Users\T-Slience\Pictures\1nf.png)

- 这种表结构设计就没有达到 1NF，要符合 1NF 我们只需把列拆分，即：把 contact 字段拆分成 name 、tel、addr 等字段。

#### 3.第二范式（2NF）

- 满足1NF ,另外包含两部分内容，一是表必须有一个主键；二是非主键字段 必须完全依赖于主键，而不能只依赖于主键的一部分。
- ![2nf](C:\Users\T-Slience\Pictures\2nf.png)

- 这种表结构设计就没有达到 2NF，因为 Discount（折扣），Quantity（数量）完全依赖于主键（OrderID），而 UnitPrice单价，ProductName产品名称 只依赖于 ProductID, 所以 OrderDetail 表不符合 2NF。
- 我们可以把【OrderDetail】表拆分为【OrderDetail】（OrderID，ProductID，Discount，Quantity）和【Product】（ProductID，UnitPrice，ProductName）这样就符合第二范式了。

#### 4.第三范式 (3NF)

-  满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。	
- ![3nf](C:\Users\T-Slience\Pictures\3nf.png)

- 这种表结构设计就没有达到 3NF，因为 OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 等非主键列都完全依赖于主键（OrderID），所以符合 2NF。不过问题是 CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。
- 我们可以把【Order】表拆分为【Order】（OrderID，OrderDate，CustomerID）和【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。

#### 5.E-R模型介绍

- E-R 模型 即 实体-关系模型,用来描述数据库存储数据的结构模型
- ![E-R模型图](C:\Users\T-Slience\Pictures\E-R模型图.png)

- 实体: 用矩形表示，并标注实体名称
- 属性: 用椭圆表示，并标注属性名称，
- 关系: 用菱形表示，并标注关系名称
  - 一对一
    - 关系也是一种数据，需要通过一个字段存储在表中
    - 1对1关系，在表A或表B中创建一个字段，存储另一个表的主键值
    -  ![1对1](C:\Users\T-Slience\Pictures\1对1.png)
  - 一对多
    - 1对多关系，在多的一方表(学生表)中创建一个字段，存储班级表的主键值
    - ![1对多](C:\Users\T-Slience\Pictures\1对多.png)
  - 多对多
    - 多对多关系，新建一张表C(中间关系表)，这个表只有两个字段，一个用于存储A的主键值，一个用于存储B的主键值
    - ![多对多](C:\Users\T-Slience\Pictures\多对多.png)

#### 6.外键约束

- 对外键字段的值进行更新和插入时会和引用表中字段的数据进行验证，数据如果不合法则更新和插入会失败，保证数据的有效性

- 提供数据的称为主表,使用数据的称为子表

- 即,子表有外键约束的字段的数据 ,必须在主表中存在此数据.

  - 如果原来存在非法数据,则无法添加外键约束
  - 如果已建立外键约束,则无法添加非法数据

  

- 格式

  - 对已存在的表 的字段添加外键约束

    - alter table 表名 add foreign key(字段名) references 主表(字段);

  - 创建表时设置外键约束

    - ```sql
      create table 子表名(
          id int not null primary key auto_increment, 
          name varchar(10), 
          s_id int not null, 
          foreign key(字段名) references 主表(字段名)
      ```

  - 删除外键约束

    - alter table 子表名 drop foreign key 外键名

    - 不知道外键名可以通过 show create table 表名 查询

      